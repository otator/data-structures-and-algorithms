/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package codes;

import codes.app.src.main.TreeNode;
import codes.app.src.main.java.codes.BinarySearch;
import codes.app.src.main.java.codes.FullLinkedList;
import codes.app.src.main.java.codes.LinkedList;
import codes.app.src.main.stacksandqueues.PseudoQueue;
import codes.app.src.main.stacksandqueues.Queue;
import codes.app.src.main.stacksandqueues.Stack;
import codes.app.src.main.tree.BinarySearchTree;
import codes.app.src.main.tree.Node;
import codes.app.src.main.tree.Tree;
import codes.app.src.main.utilites.AnimalShelter;
import codes.app.src.main.utilites.FizzBuzzTree;
import codes.app.src.main.utilites.MultiBracketValidation;
import org.junit.Test;

import java.util.ArrayList;

import static org.junit.Assert.*;

public class AppTest {
   @Test
  public void testInsert(){
     LinkedList list = new LinkedList();
     list.insert(5);
     assertTrue("test insert into linked list", list.includes(5));
   }
   @Test
  public void testIncludes(){
     LinkedList list = new LinkedList();
     list.insert(5);
     list.insert(4);
     list.insert(99);
     assertTrue(list.includes(99));
   }

   @Test
  public void testNotIncludes(){
     LinkedList list = new LinkedList();
     list.insert(5);
     list.insert(4);
     assertFalse(list.includes(99));
   }

   @Test
  public void testListValues(){
     LinkedList list = new LinkedList();
     list.insert(5);
     list.insert(4);
     assertEquals("test the values of the list", "{4} -> {5} -> NULL", list.toString());
   }


   @Test
  public void testArray(){
     int [] arr = {1,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59};
     int expectedIndex = 11;
     int value = 37;
     int actualIndex = BinarySearch.binarySearch(arr, value);
     assertEquals("test the value index of array with more than 10 values", expectedIndex, actualIndex);
   }
  @Test
  public void testLastIndexOfArray(){
    int [] arr = {1,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59};
    int expectedIndex = 16;
    int value = 59;
    int actualIndex = BinarySearch.binarySearch(arr, value);
    assertEquals("test the value index of array with more than 10 values", expectedIndex, actualIndex);
  }
  @Test
  public void testFirstIndexOfArray(){
    int [] arr = {1,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59};
    int expectedIndex = 0;
    int value = 1;
    int actualIndex = BinarySearch.binarySearch(arr, value);
    assertEquals("test the value index of array with more than 10 values", expectedIndex, actualIndex);
  }

  @Test
  public void testIndexOfOneArrayValue(){
    int [] arr = {5};
    int expectedIndex = 0;
    int value = 5;
    int actualIndex = BinarySearch.binarySearch(arr, value);
    assertEquals("test array with one value", expectedIndex, actualIndex);
  }

  @Test
  public void testIndexOfTwoArrayValues(){
    int [] arr = {11,99};
    int expectedIndex = 1;
    int value = 99;
    int actualIndex = BinarySearch.binarySearch(arr, value);
    assertEquals("test array with two values", expectedIndex, actualIndex);
  }

  @Test
  public void testEmpty(){
    int [] arr = {};
    int expectedIndex = -1;
    int value = 10;
    int actualIndex = BinarySearch.binarySearch(arr, value);
    assertEquals("test empty array must return -1", expectedIndex, actualIndex);
  }
  @Test
  public void testNotExists(){
    int [] arr = {2,4,6,8,10};
    int expectedIndex = -1;
    int value = 9;
    int actualIndex = BinarySearch.binarySearch(arr, value);
    assertEquals("test empty array must return -1", expectedIndex, actualIndex);
  }

  @Test
  public void testOneAtTheEnd(){
    FullLinkedList list = new FullLinkedList();
    list.insert(5);
    list.insert(10);
    list.insert(15);
    list.append(99);
    String expectedOutput = "{15} -> {10} -> {5} -> {99} -> NULL";
    assertEquals("tests the append of one element at the end", expectedOutput, list.toString());
  }
  @Test
  public void testManyAtTheEnd(){
    FullLinkedList list = new FullLinkedList();
    list.insert(5);
    list.insert(10);
    list.insert(15);
    list.append(99);
    list.append(-4);
    list.append(2021);
    String expectedOutput  = "{15} -> {10} -> {5} -> {99} -> {-4} -> {2021} -> NULL";
    assertEquals("tests the append of many elements at the end", expectedOutput, list.toString());
  }
  @Test
  public void testInsertBeforeTheMiddleElement(){
    FullLinkedList list = new FullLinkedList();
    list.insert(5);
    list.insert(10);
    list.insert(15);
    list.append(99);
    list.insertBefore(5, 117);
    String expectedOutput  = "{15} -> {10} -> {117} -> {5} -> {99} -> NULL";
    assertEquals("tests the insertion of element at the middle", expectedOutput, list.toString());
  }

  @Test
  public void testInsertBeforeFirstElement(){
    FullLinkedList list = new FullLinkedList();
    list.insert(5);
    list.insert(10);
    list.insert(15);
    list.append(99);
    list.insertBefore(15, 117);
    String expectedOutput  = "{117} -> {15} -> {10} -> {5} -> {99} -> NULL";
    assertEquals("tests the insertion of element before the first element", expectedOutput, list.toString());
  }

  @Test
  public void testInsertAfterTheMiddle(){
    FullLinkedList list = new FullLinkedList();
    list.append(5);
    list.append(10);
    list.append(15);
    list.append(99);
    list.append(-4);
    list.insertAfter(15, 200);
    String expectedOutput  = "{5} -> {10} -> {15} -> {200} -> {99} -> {-4} -> NULL";
    assertEquals("tests the insertion of element after the middle", expectedOutput, list.toString());
  }

  @Test
  public void testInsertAfterTheLastElement(){
    FullLinkedList list = new FullLinkedList();
    list.append(5);
    list.append(10);
    list.append(15);
    list.append(99);
    list.append(-4);
    list.insertAfter(-4, 2021);
    String expectedOutput  = "{5} -> {10} -> {15} -> {99} -> {-4} -> {2021} -> NULL";
    assertEquals("tests the insertion of element after last element", expectedOutput, list.toString());
  }
  @Test
  public void testDeleteElements(){
    FullLinkedList list = new FullLinkedList();
    list.append(5);
    list.append(10);
    list.append(15);
    list.delete(5);
    list.delete(10);
    String expectedOutput  = "{15} -> NULL";
    assertEquals("tests of deleting some elements from the list", expectedOutput, list.toString());
  }

  @Test
  public void testDeleteEmptyElement(){
    FullLinkedList list = new FullLinkedList();
    list.delete(5);
    String expectedOutput  = "NULL";
    assertEquals("tests of deleting from empty list", expectedOutput, list.toString());
  }

  @Test
  public void testKthFromEnd1(){
    FullLinkedList list = new FullLinkedList();
    list.append(1);
    list.append(3);
    list.append(8);
    list.append(2);
    int expected = 2;
    assertEquals("tests the last element in the list", expected, list.kthFromEnd(0));
  }

  @Test
  public void testKthFromEnd2(){
    FullLinkedList list = new FullLinkedList();
    list.append(1);
    list.append(3);
    list.append(8);
    list.append(2);
    int expected = 3;
    assertEquals("tests the last element in the middle", expected, list.kthFromEnd(2));
  }

  @Test
  public void testKthFromEnd3(){
    FullLinkedList list = new FullLinkedList();
    list.append(1);
    list.append(3);
    list.append(8);
    list.append(2);
    int expected = -1;
    assertEquals("tests not found index which must return -1", expected, list.kthFromEnd(10));
  }


  @Test
  public void testKthFromEndNegativeNumber(){
    FullLinkedList list = new FullLinkedList();
    list.append(1);
    list.append(3);
    list.append(8);
    list.append(2);
    int expected = -1;
    assertEquals("tests not found index which must return -1", expected, list.kthFromEnd(-2));
  }

  @Test
  public void testKthFromEndEmptyList() {
    FullLinkedList list = new FullLinkedList();
    int expected = -1;
    assertEquals("tests not found index which must return -1", expected, list.kthFromEnd(0));
  }

  @Test
  public void testZipEqual(){
    FullLinkedList list1 = new FullLinkedList();
    list1.append(1);
    list1.append(3);
    list1.append(2);

    FullLinkedList list2 = new FullLinkedList();
    list2.append(5);
    list2.append(9);
    list2.append(4);
    String expected = "{1} -> {5} -> {3} -> {9} -> {2} -> {4} -> NULL";
    LinkedList zip = FullLinkedList.zipLists(list1, list2);
    assertEquals("test two equals linked lists", expected, zip.toString());
  }

  @Test
  public void testZipDifferent(){
    FullLinkedList list1 = new FullLinkedList();
    list1.append(1);
    list1.append(3);
    list1.append(2);

    FullLinkedList list2 = new FullLinkedList();
    list2.append(5);
    list2.append(9);
    list2.append(4);
    list2.append(100);
    String expected = "{1} -> {5} -> {3} -> {9} -> {2} -> {4} -> {100} -> NULL";
    LinkedList zip = FullLinkedList.zipLists(list1, list2);
    assertEquals("test two different linked lists in length", expected, zip.toString());
  }

  @Test
  public void testOneNull(){
    FullLinkedList list1 = new FullLinkedList();

    FullLinkedList list2 = new FullLinkedList();
    list2.append(5);
    list2.append(9);
    list2.append(4);
    list2.append(100);
    String expected = "{5} -> {9} -> {4} -> {100} -> NULL";

    LinkedList zip = FullLinkedList.zipLists(list1, list2);
    assertEquals("test one empty linked lists",expected,zip.toString());
  }
  @Test
  public void testOneNull2(){
    FullLinkedList list1 = new FullLinkedList();
    list1.append(1);
    list1.append(3);
    list1.append(2);

    FullLinkedList list2 = new FullLinkedList();

    String expected = "{1} -> {3} -> {2} -> NULL";
    LinkedList zip = FullLinkedList.zipLists(list1, list2);
    assertEquals("test one empty linked lists",expected,zip.toString());
  }

  @Test
  public void testTwoNulls(){
    FullLinkedList list1 = new FullLinkedList();
    FullLinkedList list2 = new FullLinkedList();

    LinkedList zip = FullLinkedList.zipLists(list1, list2);
    assertNull("test two empty linked lists",zip);
  }

  @Test
  public void testPushOneIntoStack() {
    Stack stack = new Stack();
    Integer actual = 5;
    stack.push(5);
    assertEquals("test pushing one value into stack", actual, stack.pop());
  }

  @Test
  public void testPushManyIntoStack() {
    Stack stack = new Stack();
    Integer actual = -7;
    stack.push(5);
    stack.push(4);
    stack.push(-7);
    assertEquals("test pushing one value into stack", actual, stack.peek());
  }

  @Test
  public void testPopToEmptyStack() {
    Stack stack = new Stack();
    stack.push(5);
    stack.push(4);
    stack.push(-7);
    stack.pop();
    stack.pop();
    stack.pop();
    assertNull(stack.peek());
  }

  @Test
  public void testPopEmptyStack() {
    Stack stack = new Stack();
    assertNull(stack.pop());
  }

  @Test
  public void testOneEnqueue() {
    Queue queue = new Queue();
    Integer actual = 12;
    queue.enqueue(12);
    assertEquals("test enqueuing one value into queue", actual, queue.dequeue());
  }

  @Test
  public void testManyEnqueue() {
    Queue queue = new Queue();
    Integer actual = 100;
    queue.enqueue(100);
    queue.enqueue(1);
    queue.enqueue(2);
    queue.enqueue(3);
    assertEquals("test enqueuing one value into queue", actual, queue.peek());
  }

  @Test
  public void testEmptyQueue() {
    Queue queue = new Queue();
    queue.enqueue(96);
    queue.enqueue(2020);
    queue.enqueue(2021);
    queue.dequeue();
    queue.dequeue();
    queue.dequeue();
    assertNull(queue.peek());
  }

  @Test
  public void testEmptyQueue2() {
    Queue queue = new Queue();
    assertNull(queue.dequeue());
  }

  //test of PseudoQueue class (queue with stacks)

  @Test
  public void testEnqueue(){
    PseudoQueue queue = new PseudoQueue();
    queue.enqueue(10);
    queue.enqueue(15);
    queue.enqueue(20);
    String expected = "front -> {10} -> {15} -> {20} -> rare";
    assertEquals("test enqueue method", expected, queue.toString());
  }

  @Test
  public void testDequeue(){
    PseudoQueue queue = new PseudoQueue();
    queue.enqueue(10);
    queue.enqueue(15);
    queue.enqueue(20);
    Integer expected = 10;
    assertEquals("test dequeue method", expected, queue.dequeue());
  }

  @Test
  public void testMultiDequeue(){
    PseudoQueue queue = new PseudoQueue();
    queue.enqueue(10);
    queue.enqueue(15);
    queue.enqueue(20);
    queue.dequeue();
    queue.dequeue();
    String expected = "front -> {20} -> rare";
    assertEquals("test multi dequeue method", expected, queue.toString());
  }

  @Test
  public void testDequeueUntilEmpty(){
    PseudoQueue queue = new PseudoQueue();
    queue.enqueue(10);
    queue.enqueue(15);
    queue.enqueue(20);
    queue.dequeue();
    queue.dequeue();
    queue.dequeue();
    assertNull(queue.dequeue());
  }

  //test  AnimalShelter class

  @Test
  public void testEmptyShelter(){
    AnimalShelter shelter = new AnimalShelter();
    assertNull(shelter.dequeue("cat"));
  }

  @Test
  public void testOneAnimalShelter(){
    AnimalShelter shelter = new AnimalShelter();
    shelter.enqueue("cat");
    String expected = "cat";
    assertEquals("test dequeue from shelter with one animal", expected, shelter.dequeue("cat"));
  }

  @Test
  public void testNotFoundAnimalInShelter(){
    AnimalShelter shelter = new AnimalShelter();
    shelter.enqueue("cat");
    shelter.enqueue("cat");
    shelter.enqueue("cat");
    shelter.enqueue("cat");
    assertNull(shelter.dequeue("dog"));
  }

  @Test
  public void testAddAnimalsInShelter(){
    AnimalShelter shelter = new AnimalShelter();
    shelter.enqueue("cat");
    shelter.enqueue("dog");
    shelter.enqueue("dog");
    shelter.enqueue("cat");
    shelter.enqueue("dog");
    shelter.enqueue("cat");
    shelter.enqueue("dog");
    shelter.enqueue("dog");
    shelter.enqueue("dog");
    shelter.enqueue("dog");
    String expected ="front ➔ {cat} ➔ {dog} ➔ {dog} ➔ {cat} ➔ {dog} ➔ {cat} ➔ {dog} ➔ {dog} ➔ {dog} ➔ {dog} ➔ rear";
    assertEquals("tests add many cats and dogs into the shelter",expected, shelter.toString());
  }

  @Test
  public void testAddDifferentAnimalsInShelter(){
    AnimalShelter shelter = new AnimalShelter();
    shelter.enqueue("dog");
    shelter.enqueue("cow");
    shelter.enqueue("mouse");
    shelter.enqueue("cat");
    shelter.enqueue("donkey");
    shelter.enqueue("giraffe");
    shelter.enqueue("cat");
    String expected ="front ➔ {dog} ➔ {cat} ➔ {cat} ➔ rear";
    assertEquals("tests add different animals rather that cats and dogs into the shelter",expected, shelter.toString());
  }

  @Test
  public void testGetDifferentAnimalsFromShelter(){
    AnimalShelter shelter = new AnimalShelter();
    shelter.enqueue("dog");
    shelter.enqueue("cat");
    shelter.enqueue("cat");
    assertNull(shelter.dequeue("monkey"));
  }

  @Test
  public void testMultiBracketValidationEmptyCode(){
    String code = "";
    assertTrue("must return true for empty code", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationOne1(){
    String code = "(";
    assertFalse("must return false for one open bracket", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationOne2(){
    String code = "}";
    assertFalse("must return false for one close bracket", MultiBracketValidation.multiBracketValidation(code));
  }


  @Test
  public void testMultiBracketValidationCode1(){
    String code = "{}";
    assertTrue("must return true for balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode2(){
    String code = "{}(){}";
    assertTrue("must return true for balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode3(){
    String code = "()[[Extra Characters]]";
    assertTrue("must return true for balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode4(){
    String code = "(){}[[]]";
    assertTrue("must return true for balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode5(){
    String code = "{}{Code}[Fellows](())";
    assertTrue("must return true for balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode6(){
    String code = "[({}]";
    assertFalse("must return false for NOT balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode7(){
    String code = "(](";
    assertFalse("must return false for NOT  balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode8(){
    String code = "{{(})}";
    assertFalse("must return false for NOT balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testMultiBracketValidationCode9(){
    String code = "[]][][][][][][[[][][][][][][][]]]]";
    assertFalse("must return false for NOT balanced brackets", MultiBracketValidation.multiBracketValidation(code));
  }

  @Test
  public void testEmptyTree(){
    BinarySearchTree tree = new BinarySearchTree();
    assertTrue("tests that the tree is empty before adding any nodes",tree.isEmpty());
  }

  @Test
  public void testTreeNullRoot(){
    BinarySearchTree tree = new BinarySearchTree();
    assertNull("test that the root is null before adding any new node",tree.root);
  }

  @Test
  public void testTreeRoot(){
    BinarySearchTree tree = new BinarySearchTree();
    Integer value = 15;
    tree.add(value);
    assertEquals("test the root value, must return true", value, tree.root.value);
  }

  @Test
  public void testAddManyNodes(){
    BinarySearchTree tree = new BinarySearchTree();
    tree.add(15);
    tree.add(12);
    tree.add(20);
    tree.add(0);
    tree.add(13);
    tree.add(18);
    String output = "root ➔ 15 ➔ 12 ➔ 0 ➔ 13 ➔ 20 ➔ 18 ➔  leaf";
    assertEquals("test the root value, must return true", output, tree.toString());
  }

  @Test
  public void testPreOrderTraversal(){
    BinarySearchTree tree = new BinarySearchTree();
    tree.add(15);
    tree.add(12);
    tree.add(20);
    tree.add(0);
    tree.add(13);
    tree.add(18);
    ArrayList<Integer> list = new ArrayList<>();
    list.add(15);
    list.add(12);
    list.add(0);
    list.add(13);
    list.add(20);
    list.add(18);
    tree.preOrder(tree.root);
    assertEquals("tests pre-order traversal", list, tree.preOrderList);
  }

  @Test
  public void testInOrderTraversal(){
    BinarySearchTree tree = new BinarySearchTree();
    tree.add(15);
    tree.add(12);
    tree.add(20);
    tree.add(0);
    tree.add(13);
    tree.add(18);

    ArrayList<Integer> list = new ArrayList<>();
    list.add(0);
    list.add(12);
    list.add(13);
    list.add(15);
    list.add(18);
    list.add(20);
    tree.inOrder(tree.root);
    assertEquals("tests in-order traversal", list, tree.inOrderList);
  }

  @Test
  public void testPostOrderTraversal(){
    BinarySearchTree tree = new BinarySearchTree();
    tree.add(15);
    tree.add(12);
    tree.add(20);
    tree.add(0);
    tree.add(13);
    tree.add(18);

    ArrayList<Integer> list = new ArrayList<>();
    list.add(0);
    list.add(13);
    list.add(12);
    list.add(18);
    list.add(20);
    list.add(15);
    tree.postOrder(tree.root);
    assertEquals("tests post-order traversal", list, tree.postOrderList);
  }

  @Test
  public void testContainsTrue(){
    BinarySearchTree tree = new BinarySearchTree();
    tree.add(15);
    tree.add(12);
    tree.add(20);
    tree.add(0);
    tree.add(13);
    tree.add(18);
    assertTrue("test that a value exists in tree", tree.contains(20, tree.root));
  }

  @Test
  public void testContainsFasle(){
    BinarySearchTree tree = new BinarySearchTree();
    tree.add(15);
    tree.add(12);
    tree.add(20);
    tree.add(0);
    tree.add(13);
    tree.add(18);
    assertFalse("test that a value NOT  exists in tree", tree.contains(99, tree.root));
  }

  @Test
  public void testContainsEmpty(){
    BinarySearchTree tree = new BinarySearchTree();
    assertFalse("test that a value exists in empty tree", tree.contains(99, tree.root));
  }

  @Test
  public void testMaximumValueTree(){
    Tree tree = new Tree();
    // hard-coded tree

    // root
    tree.root = new Node(2);

    // left side
    tree.root.left = new Node(7);
    tree.root.left.left = new Node(2);
    tree.root.left.right = new Node(6);
    tree.root.left.right.left = new Node(5);
    tree.root.left.right.right = new Node(11);

    // right side

    tree.root.right = new Node(5);
    tree.root.right.right = new Node(9);
    tree.root.right.right.left = new Node(4);
    tree.findMaximumValue(tree.root);
    Integer expected = 11;
    assertEquals("tests the max value in tree which is 11", expected, tree.max);
  }

  @Test
  public void testMaximumOneValueTree(){
    Tree tree = new Tree();
    // hard-coded tree

    // root
    tree.root = new Node(2);
    tree.findMaximumValue(tree.root);
    Integer expected = 2;
    assertEquals("tests the max value in one-value tree which is 2", expected, tree.max);
  }

  @Test
  public void testMaximumValueEmptyTree(){
    Tree tree = new Tree();
    Integer expected = Integer.MIN_VALUE;
    assertEquals("tests the max value in empty tree, the max will be the minimum value of Integer", expected, tree.max);
  }

  @Test
  public void testBreadthFirst(){
    Tree tree = new Tree();
    // hard-coded tree

    // root
    tree.root = new Node(2);

    // left side
    tree.root.left = new Node(7);
    tree.root.left.left = new Node(2);
    tree.root.left.right = new Node(6);
    tree.root.left.right.left = new Node(5);
    tree.root.left.right.right = new Node(11);

    // right side

    tree.root.right = new Node(5);
    tree.root.right.right = new Node(9);
    tree.root.right.right.left = new Node(4);

    tree.breadthFirst(tree.root);
    ArrayList<Integer> expected= new ArrayList<>();
    expected.add(2);
    expected.add(7);
    expected.add(5);
    expected.add(2);
    expected.add(6);
    expected.add(9);
    expected.add(5);
    expected.add(11);
    expected.add(4);
    assertEquals("test breadth first tree", expected, tree.listOfBreadthFirst);

  }
  @Test
  public void testBreadthFirstOneValue(){
    Tree tree = new Tree();
    // hard-coded tree

    // root
    tree.root = new Node(2);

    tree.breadthFirst(tree.root);
    ArrayList<Integer> expected= new ArrayList<>();
    expected.add(2);
    assertEquals("test breadth first tree", expected, tree.listOfBreadthFirst);

  }

  @Test
  public void testBreadthFirstEmpty(){
    Tree tree = new Tree();
    // hard-coded tree


    tree.breadthFirst(tree.root);
    ArrayList<Integer> expected= new ArrayList<>();
    assertEquals("test breadth first tree", expected, tree.listOfBreadthFirst);

  }

  @Test
  public void testEmptyFizzBuzzTree(){}{
    FizzBuzzTree tree = new FizzBuzzTree();
    tree.fizzBuzzTree(tree.root);
    assertNull("test empty fizz buzz tree", tree.root);
  }

  @Test
  public void testFizzBuzzTreeRoot1(){}{
    FizzBuzzTree tree = new FizzBuzzTree();
    tree.fizzBuzzTree(tree.root);
    tree.root = new TreeNode(3);

    // left side
    tree.root.left = new TreeNode(5);
    tree.root.left.left = new TreeNode(10);
    tree.root.left.right = new TreeNode(15);
    tree.root.left.right.left = new TreeNode(20);
    tree.root.left.right.right = new  TreeNode(25);

    // right side
    tree.root.right = new TreeNode(30);
    tree.root.right.right = new TreeNode(35);
    tree.root.right.right.left = new TreeNode(79);
    tree.fizzBuzzTree(tree.root);
    assertEquals("test the root is equal to fizz", "Fizz", tree.root.value);
  }

  @Test
  public void testFizzBuzzTreeRoot2(){}{
    FizzBuzzTree tree = new FizzBuzzTree();
    tree.fizzBuzzTree(tree.root);
    tree.root = new TreeNode(5);

    tree.fizzBuzzTree(tree.root);
    assertEquals("test the root is equal to buzz", "Buzz", tree.root.value);
  }

  @Test
  public void testFizzBuzzTreeRoot3(){}{
    FizzBuzzTree tree = new FizzBuzzTree();
    tree.fizzBuzzTree(tree.root);
    tree.root = new TreeNode(30);

    tree.fizzBuzzTree(tree.root);
    assertEquals("test the root is equal to fizz buzz", "FizzBuzz", tree.root.value);
  }
  @Test
  public void testFizzBuzzTreeRoot4(){}{
    FizzBuzzTree tree = new FizzBuzzTree();
    tree.fizzBuzzTree(tree.root);
    tree.root = new TreeNode(101);

    tree.fizzBuzzTree(tree.root);
    assertEquals("test the root is equal to '101' ", "101", tree.root.value);
  }
  @Test
  public void testFizzBuzzTree(){}{
    FizzBuzzTree tree = new FizzBuzzTree();
    tree.fizzBuzzTree(tree.root);
    tree.root = new TreeNode(3);

    // left side
    tree.root.left = new TreeNode(7);
    tree.root.left.left = new TreeNode(4);
    tree.root.left.right = new TreeNode(15);
    tree.root.left.right.left = new TreeNode(21);
    tree.root.left.right.right = new  TreeNode(25);

    // right side
    tree.root.right = new TreeNode(30);
    tree.root.right.right = new TreeNode(0);
    tree.root.right.right.left = new TreeNode(79);
    tree.fizzBuzzTree(tree.root);
    String expected = "root ➔ Fizz ➔ 7 ➔ 4 ➔ FizzBuzz ➔ Fizz ➔ Buzz ➔ FizzBuzz ➔ FizzBuzz ➔ 79 ➔  leaf";
    assertEquals("test the all tree nodes", expected, tree.toString());
  }
}
